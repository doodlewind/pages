
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>将 React 渲染到嵌入式液晶屏 | ewind the doodler</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="doodlewind">
    

    
    <meta name="description" content="我们都知道，React 最大的卖点之一，就是 Learn once, write anywhere 的通用性。但如何才能在浏览器之外，甚至在 Node.js 之外，用 React 渲染 UI 呢？本文将带你用 React 直通嵌入式驱动层，让现代前端技术与古老的硬件无缝结合。">
<meta name="keywords" content="Web">
<meta property="og:type" content="article">
<meta property="og:title" content="将 React 渲染到嵌入式液晶屏">
<meta property="og:url" content="https://ewind.us/2019/react-ssd1306/index.html">
<meta property="og:site_name" content="ewind the doodler">
<meta property="og:description" content="我们都知道，React 最大的卖点之一，就是 Learn once, write anywhere 的通用性。但如何才能在浏览器之外，甚至在 Node.js 之外，用 React 渲染 UI 呢？本文将带你用 React 直通嵌入式驱动层，让现代前端技术与古老的硬件无缝结合。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ewind.us/images/react-ssd1306/chip-view.jpg">
<meta property="og:image" content="https://ewind.us/images/react-ssd1306/pi-with-oled.jpg">
<meta property="og:image" content="https://ewind.us/images/react-ssd1306/react-arch-1.jpg">
<meta property="og:image" content="https://ewind.us/images/react-ssd1306/react-arch-2.jpg">
<meta property="og:image" content="https://ewind.us/images/react-ssd1306/pi-success.jpg">
<meta property="og:updated_time" content="2019-11-01T02:00:10.492Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="将 React 渲染到嵌入式液晶屏">
<meta name="twitter:description" content="我们都知道，React 最大的卖点之一，就是 Learn once, write anywhere 的通用性。但如何才能在浏览器之外，甚至在 Node.js 之外，用 React 渲染 UI 呢？本文将带你用 React 直通嵌入式驱动层，让现代前端技术与古老的硬件无缝结合。">
<meta name="twitter:image" content="https://ewind.us/images/react-ssd1306/chip-view.jpg">
<meta name="twitter:creator" content="@i94ewind">

    
    <link rel="alternative" href="/atom.xml" title="ewind the doodler" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo-app.png">
    <link rel="apple-touch-icon-precomposed" href="/img/logo-app.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ewind the doodler" title="ewind the doodler"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ewind the doodler">ewind the doodler</a></h1>
				<h2 class="blog-motto">我想超越这平凡的生活，注定现在就是漂泊</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/react-ssd1306/" title="将 React 渲染到嵌入式液晶屏" itemprop="url">将 React 渲染到嵌入式液晶屏</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="doodlewind" target="_blank" itemprop="author">doodlewind</a>
		
  <p class="article-time">
    <time datetime="2019-10-30T16:00:00.000Z" itemprop="datePublished"> 发表于 2019-10-31</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景概述"><span class="toc-number">1.</span> <span class="toc-text">背景概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将-React-移植到嵌入式-JS-引擎上"><span class="toc-number">2.</span> <span class="toc-text">将 React 移植到嵌入式 JS 引擎上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于-C-语言驱动硬件"><span class="toc-number">3.</span> <span class="toc-text">基于 C 语言驱动硬件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为-JS-引擎封装-C-语言扩展"><span class="toc-number">4.</span> <span class="toc-text">为 JS 引擎封装 C 语言扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-React-渲染后端"><span class="toc-number">5.</span> <span class="toc-text">实现 React 渲染后端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源"><span class="toc-number">6.</span> <span class="toc-text">资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-number">7.</span> <span class="toc-text">后记</span></a></li></ol>
		
		</div>
		
		<p>我们都知道，React 最大的卖点之一，就是 Learn once, write anywhere 的通用性。但如何才能在浏览器之外，甚至在 Node.js 之外，用 React 渲染 UI 呢？本文将带你用 React 直通嵌入式驱动层，让现代前端技术与古老的硬件无缝结合。</p>
<a id="more"></a>
<h2 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h2><p>本次我们的渲染目标，是一块仅 0.96 寸大的点阵液晶屏，型号为 SSD1306。它的分辨率仅 128x64，你可能在早期黑白 MP3 时代用它滚动播放过歌词。这块芯片到底有多小呢？我拍了张实物对比图：</p>
<p><img src="https://ewind.us/images/react-ssd1306/chip-view.jpg" alt></p>
<p>一般的 PC 显然不会直接支持这种硬件，因此我们需要嵌入式的开发环境——我选择了最方便的树莓派。</p>
<p>虽然树莓派已经具备了完善的 Python 和 Node.js 等现成的语言环境，但我希望挑战极限，按照「能够将 React 运行在最低配置的硬件环境上」的方式来做技术选型。为此我寻找的是面向嵌入式硬件的超轻量 JS 解释器，来替代浏览器和 Node.js 上较为沉重的 V8。最后我选择了 <a href="https://bellard.org/quickjs/" target="_blank" rel="noopener">QuickJS</a>，一个年轻但系出名门的 JS 引擎。</p>
<p>所以简单说，我们的目标是<strong>打通 React → QuickJS → 树莓派 → SSD1306 芯片这四个体系</strong>。这个初看起来困难的目标，可以拆分为如下的几个步骤：</p>
<ul>
<li>将 React 移植到嵌入式 JS 引擎上</li>
<li>基于 C 语言驱动硬件</li>
<li>为 JS 引擎封装 C 语言扩展</li>
<li>实现 React 渲染后端</li>
</ul>
<p>上面的每一步虽然都不算难，但也都足够写篇独立的技术博客了。为保持可读性，本文只能尽量覆盖核心概念与关键步骤。不过我可以先向你保证，最后的整个项目不仅代码足够简单，还是自由而开源的。</p>
<p>让我们开始吧！</p>
<h2 id="将-React-移植到嵌入式-JS-引擎上"><a href="#将-React-移植到嵌入式-JS-引擎上" class="headerlink" title="将 React 移植到嵌入式 JS 引擎上"></a>将 React 移植到嵌入式 JS 引擎上</h2><p>其实，QuickJS 并不是唯一的嵌入式 JS 引擎，之前社区已有 DukTape 和 XS 等不少面向 IoT 硬件的 JS 引擎，但一直不温不火。相比之下 QuickJS 最吸引我的地方，有这么几点：</p>
<ul>
<li><strong>几乎完整的 ES2019 支持</strong>。从 ES Module 到 async 和 Proxy，这些我们早已习惯的 Modern JS 语法，都是 QuickJS 已经支持，并通过了 Test262 测试的。相比之下，其他嵌入式 JS 引擎连 ES6 的支持都未必足够。</li>
<li><strong>轻便灵活、可嵌入性强</strong>。很多前端同学喜欢深入研究的 V8 引擎，其实连自己编译一份都相当困难。相比之下 QuickJS 无任何依赖，一句 make 就能编译好，二进制体积不到 700KB，也非常容易嵌入各类原生项目。</li>
<li><strong>作者的个人实力</strong>。作者 Fabrice Bellard 对我来说是神级的存在。像安卓模拟器底层的 QEMU 和音视频开发者必备的 FFmpeg，都是他创造的杰作。每当我技术有些进步，访问他的 <a href="https://bellard.org/" target="_blank" rel="noopener">Home Page</a>  时总能让我清晰地认识到自己的渺小。</li>
</ul>
<p>但是，QuickJS 毕竟还只是个刚发布几个月的新项目而已，敢于尝鲜的人并不多。即便通过了各种单元测试，它真的能稳定运行起 React 这样的工业级 JS 项目吗？这是决定这条技术路线可行性的关键问题。</p>
<p>为此，我们当然需要先实际用上 QuickJS。它的源码是跨平台的，并非只能在 Linux 或树莓派上运行。在我的 macOS 上，拉下代码一套素质三连即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> quickjs</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以在终端输入 <code>qjs</code> 命令来进入 QuickJS 解释器了。只要形如 <code>qjs foo.js</code> 的形式，即可用它执行你的脚本。再加上 <code>-m</code> 参数，它就能支持载入 ES Module (ESM) 形式的模块，直接运行起整个模块化的 JS 项目了。</p>
<blockquote>
<p>注意，在 QuickJS 中使用 ESM 时，必须给路径加上完整的  <code>.js</code> 后缀。这和浏览器中对直接加载 ESM 的要求是一致的。</p>
</blockquote>
<p>不过，QuickJS 并不能直接运行「我们日常写的那种 React」，毕竟标签式的 JSX 只是方言，不是业界标准。怎么办呢？作为变通，我引入了辅助的 Node.js 环境，先用 Rollup 打包并转译 JSX 代码为 ESM 格式，再交给 QuickJS 执行。这个辅助环境的 node_modules 体积只有 10M 不到，具体配置不再赘述。</p>
<p>很快关键的一步就来了，你觉得 <code>qjs react.js</code> 真的能用吗？这时就体现出 React 的设计优越性了——早在两年前 React 16.0 发布时，React 就在架构上分离了上层的 <code>react</code> 和下层的默认 DOM 渲染器 <code>react-dom</code>，它们通过 <code>react-reconciler</code> 封装的 Fiber 中间层来连接。<code>react</code> 包没有对 DOM 的依赖，是可以独立在纯 JS 环境下运行的。这种工程设计虽然增大了整体的项目体积，但对于我们这种要定制渲染后端的场合则非常有用，也是个 React 比 Vue 已经领先了两年有余的地方。如何验证 React 可用呢？编写个最简单的无状态组件试试就行了：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./polyfill.js'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(props.hello)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">hello</span>=<span class="string">&#123;</span>'<span class="attr">QuickJS</span>'&#125; /&gt;</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意到 <code>polyfill.js</code> 了吗？这是将 React 移植到 QuickJS 环境所需的兼容代码。看起来这种兼容工作可能很困难，但其实非常简单，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuickJS 约定的全局变量为 globalThis</span></span><br><span class="line">globalThis.process = &#123; <span class="attr">env</span>: &#123; <span class="attr">NODE_ENV</span>: <span class="string">'development'</span> &#125; &#125;</span><br><span class="line">globalThis.console.warn = <span class="built_in">console</span>.log</span><br></pre></td></tr></table></figure>
<p>这么点代码由 Rollup 打包后，执行 <code>qjs dist.js</code> 即可获得这样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qjs ./dist.js</span><br><span class="line">QuickJS</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>这说明 <code>React.createElement</code> 能正确执行，Props 的传递也没有问题。这个结果让我很兴奋，因为即使停在这一步，也已经说明了：</p>
<ul>
<li>QuickJS 完全可以直接运行工业界中 Battle-Tested 的框架。</li>
<li><code>npm install react</code> 的源码，能够<strong>一行不改地</strong>运行在符合标准的 JS 引擎上。</li>
</ul>
<p>好了，QuickJS 牛逼！React 牛逼！接下来该干嘛呢？</p>
<h2 id="基于-C-语言驱动硬件"><a href="#基于-C-语言驱动硬件" class="headerlink" title="基于 C 语言驱动硬件"></a>基于 C 语言驱动硬件</h2><p>我们已经让 React 顺利地在 QuickJS 引擎上执行了。但别忘了我们的目标——将 React 直接渲染到<strong>液晶屏</strong>！该如何在液晶屏上渲染内容呢？最贴近硬件的 C 语言肯定是最方便的。但在开始编码之前，我们需要搞明白这些概念：</p>
<ul>
<li>要想控制 SSD1306 这块芯片，最简单的方式是通过 I2C 通信协议。这就和 U 盘支持 USB 协议是一个道理。</li>
<li>一般的 PC 主板上没有 I2C 接口，但树莓派上有，只要连接几个针脚就行。</li>
<li>连接了支持 I2C 的设备后，就可以在操作系统中控制它了。我们知道 Linux 里一切皆文件，因此这个屏幕也会被当成文件，挂载到 <code>/dev</code> 目录下。</li>
<li>对于文件，只需通过 C 语言编写 Unix 的 <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="noopener">open</a> / <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener">write</a> 等系统调用，就能读写控制了。不过 I2C 显示屏毕竟不是普通文件，是通过 Linux 内核里的驱动控制的。为此我们需要安装 <a href="https://www.kernel.org/doc/Documentation/i2c/dev-interface" target="_blank" rel="noopener">libi2c-dev</a> 这个包，以便在用户态通过 <a href="http://man7.org/linux/man-pages/man2/ioctl.2.html" target="_blank" rel="noopener">ioctl</a> 系统调用来控制它。</li>
</ul>
<p>我们首先需要将屏幕芯片连接到树莓派上。方法如下（树莓派引脚号可以用 <code>pinout</code> 命令查看）：</p>
<ul>
<li>芯片 Vcc 端接树莓派 1 号引脚，这是 3.3V 的电源输入</li>
<li>芯片 Gnd 端接树莓派 14 号引脚，这是地线</li>
<li>芯片 SCL 端接树莓派 5 号引脚，这是 I2C 规范的 SCL 口</li>
<li>芯片 SDA 端接树莓派 3 号引脚，这是 I2C 规范的 SDA 口</li>
</ul>
<p>连接好之后，大概是这样的：</p>
<p><img src="https://ewind.us/images/react-ssd1306/pi-with-oled.jpg" alt></p>
<p>然后，在树莓派「开始菜单」的 System Configuration 中，启用 Interface 中的 I2C 项（这步也能敲命令处理）并重启，即可启用 I2C 支持。</p>
<p>硬件和系统都配置好之后，我们来安装 I2C 的一些工具包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install i2c-tools libi2c-dev</span><br></pre></td></tr></table></figure>
<p>如何验证上面这套流程 OK 了呢？使用 <code>i2cdetect</code> 命令即可。如果看到下面这样在 <code>3c</code> 位置有值的结果，说明屏幕已经正确挂载了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ i2cdetect -y 1</span><br><span class="line">     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span><br><span class="line">00:          -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- --</span><br><span class="line">40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span><br><span class="line">70: -- -- -- -- -- -- -- --</span><br></pre></td></tr></table></figure>
<p>环境配置完成后，我们就可以编写用 open / write / ioctl 等系统调用来控制屏幕的 C 代码了。这需要对 I2C 通信协议有些了解，好在有不少现成的轮子可以用。这里用的是 <a href="https://github.com/bitbank2/oled_96" target="_blank" rel="noopener">oled96</a> 库，基于它的示例代码大概这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"oled96.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> iChannel = <span class="number">1</span>, bFlip = <span class="number">0</span>, bInvert = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iOLEDAddr = <span class="number">0x3c</span>;</span><br><span class="line">    <span class="keyword">int</span> iOLEDType = OLED_128x64;</span><br><span class="line">    oledInit(iChannel, iOLEDAddr, iOLEDType, bFlip, bInvert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清屏后渲染文字和像素</span></span><br><span class="line">    oledFill(<span class="number">0</span>);</span><br><span class="line">    oledWriteString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Hello OLED!"</span>, FONT_SMALL);</span><br><span class="line">    oledSetPixel(<span class="number">42</span>, <span class="number">42</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在用户输入后关闭屏幕</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Press ENTER to quit!\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    oledShutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例只需要 <code>gcc demo.c</code> 命令就能运行。不出意外的话，运行编译产生的 <code>./a.out</code> 即可点亮屏幕。这一步编写的代码也很浅显易懂，真正较复杂的地方在于 oled96 驱动层的通信实现。有兴趣的同学可以读读它的源码噢。</p>
<h2 id="为-JS-引擎封装-C-语言扩展"><a href="#为-JS-引擎封装-C-语言扩展" class="headerlink" title="为 JS 引擎封装 C 语言扩展"></a>为 JS 引擎封装 C 语言扩展</h2><p>现在，React 世界和硬件世界分别都能正常运转了。但如何连接它们呢？我们需要为 QuickJS 引擎开发 C 语言模块。</p>
<p>QuickJS 中默认内置了 <code>os</code> 和 <code>std</code> 两个原生模块，比如我们司空见惯的这种代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="string">'Hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;hello&#125;</span> World!`</span>)</span><br></pre></td></tr></table></figure>
<p>其实在 QuickJS 中也能换成这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> std <span class="keyword">from</span> <span class="string">'std'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="string">'Hello'</span></span><br><span class="line">std.out.printf(<span class="string">'%s World!'</span>, hello)</span><br></pre></td></tr></table></figure>
<p>有没有种 C 语言换壳的感觉？这里的 <code>std</code> 模块其实就是作者为 C 语言 <code>stdlib.h</code> 和 <code>stdio.h</code> 实现的 JS Binding。那我如果想自己实现其他的 C 模块，该怎么办呢？官方文档大手一挥，告诉你「直接照我的源码来写就行」——敢把核心源码当作面向小白的示例，可能这就是大神吧。</p>
<p>一番折腾后，我发现 QuickJS 在接入原生模块时的设计，非常的「艺高人胆大」。首先我们要知道的是，在 <code>qjs</code> 之外，QuickJS 还提供了个 <code>qjsc</code> 命令，能将一份写了 Hello World 的 <code>hello.js</code> 直接编译到二进制可执行文件，或者这样的 C 代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* File generated automatically by the QuickJS compiler. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"quickjs-libc.h"</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> qjsc_hello_size = <span class="number">87</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> qjsc_hello[<span class="number">87</span>] = &#123;</span><br><span class="line"> <span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x0e</span>, <span class="number">0x63</span>, <span class="number">0x6f</span>, <span class="number">0x6e</span>, <span class="number">0x73</span>, <span class="number">0x6f</span>,</span><br><span class="line"> <span class="number">0x6c</span>, <span class="number">0x65</span>, <span class="number">0x06</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span>, <span class="number">0x67</span>, <span class="number">0x16</span>, <span class="number">0x48</span>,</span><br><span class="line"> <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span>, <span class="number">0x20</span>, <span class="number">0x57</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>,</span><br><span class="line"> <span class="number">0x6c</span>, <span class="number">0x64</span>, <span class="number">0x22</span>, <span class="number">0x65</span>, <span class="number">0x78</span>, <span class="number">0x61</span>, <span class="number">0x6d</span>, <span class="number">0x70</span>,</span><br><span class="line"> <span class="number">0x6c</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x2f</span>, <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>,</span><br><span class="line"> <span class="number">0x6f</span>, <span class="number">0x2e</span>, <span class="number">0x6a</span>, <span class="number">0x73</span>, <span class="number">0x0d</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x9e</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x14</span>, <span class="number">0x01</span>, <span class="number">0xa0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x39</span>,</span><br><span class="line"> <span class="number">0xd0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x43</span>, <span class="number">0xd1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0xd2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x01</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0xcc</span>, <span class="number">0x28</span>, <span class="number">0xa6</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  JSRuntime *rt;</span><br><span class="line">  JSContext *ctx;</span><br><span class="line">  rt = JS_NewRuntime();</span><br><span class="line">  ctx = JS_NewContextRaw(rt);</span><br><span class="line">  JS_AddIntrinsicBaseObjects(ctx);</span><br><span class="line">  js_std_add_helpers(ctx, argc, argv);</span><br><span class="line">  js_std_eval_binary(ctx, qjsc_hello, qjsc_hello_size, <span class="number">0</span>);</span><br><span class="line">  js_std_loop(ctx);</span><br><span class="line">  JS_FreeContext(ctx);</span><br><span class="line">  JS_FreeRuntime(rt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的 Hello World 去哪了？就在这个大数组的<strong>字节码</strong>里呢。这里一些形如 <code>JS_NewRuntime</code> 的 C 方法，其实就是 QuickJS 对外 API 的一部分。你可以参考这种方式，在原生项目里接入 QuickJS——真正的大神，即便把自己的代码编译一遍，还是示例级的教程代码。</p>
<p>搞懂这个过程后不难发现，QuickJS 中最简单的原生模块使用方式，其实是这样的：</p>
<ol>
<li>用 <code>qjsc</code> 将全部 JS 代码，编译成 C 语言的 <code>main.c</code> 入口</li>
<li>依次将你的各个 C 源码，用 <code>gcc -c</code> 命令编译为 <code>.o</code> 格式的目标文件</li>
<li>编译 <code>main.c</code> 并链接上这些 <code>.o</code> 文件，获得最终的 <code>main</code> 可执行文件</li>
</ol>
<p>看懂了吗？这个操作的核心在于<strong>先把 JS 编译成普通的 C，再在 C 的世界里链接各种原生模块</strong>。虽然有些奇幻，但好处是这样不需要魔改 QuickJS 源码就能实现。按这种方式，我基于 oled96 实现了个名为 <code>renderer.c</code> 的 C 模块，它会提供名为 <code>renderer</code> 的 JS 原生模块。其整体实现大致是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于初始化 OLED 的 C 函数</span></span><br><span class="line"><span class="function">JSValue <span class="title">nativeInit</span><span class="params">(JSContext *ctx, JSValueConst this_val, <span class="keyword">int</span> argc, JSValueConst *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bInvert = JS_ToBool(ctx, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bFlip = JS_ToBool(ctx, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> iChannel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iOLEDAddr = <span class="number">0x3c</span>;</span><br><span class="line">    <span class="keyword">int</span> iOLEDType = OLED_128x64;</span><br><span class="line">    oledInit(iChannel, iOLEDAddr, iOLEDType, bFlip, bInvert);</span><br><span class="line">    oledFill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> JS_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于绘制像素的 C 函数</span></span><br><span class="line"><span class="function">JSValue <span class="title">nativeDrawPixel</span><span class="params">(JSContext *ctx, JSValueConst this_val, <span class="keyword">int</span> argc, JSValueConst *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    JS_ToInt32(ctx, &amp;x, argv[<span class="number">0</span>]);</span><br><span class="line">    JS_ToInt32(ctx, &amp;y, argv[<span class="number">1</span>]);</span><br><span class="line">    oledSetPixel(x, y, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> JS_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 JS 侧所需的函数名与参数长度信息</span></span><br><span class="line"><span class="keyword">const</span> JSCFunctionListEntry nativeFuncs[] = &#123;</span><br><span class="line">    JS_CFUNC_DEF(<span class="string">"init"</span>, <span class="number">2</span>, nativeInit),</span><br><span class="line">    JS_CFUNC_DEF(<span class="string">"drawPixel"</span>, <span class="number">2</span>, nativeDrawPixel)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的一些胶水代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>整个包含了 C 模块的项目编译步骤，如果手动执行则较为复杂。因此我们选择引入 GNU Make 来表达整个构建流程。由于是第一次写 Makefile，这个过程对我有些困扰。不过搞懂原理后，它其实也没那么可怕。感兴趣的同学可以自己查看后面开源仓库地址中的实现噢。</p>
<p>只要上面的 C 模块编译成功，我们就能用这种前端同学们信手拈来的 JS 代码，直接驱动这块屏幕了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; setTimeout &#125; <span class="keyword">from</span> <span class="string">'os'</span></span><br><span class="line"><span class="keyword">import</span> &#123; init, clear, drawText &#125; <span class="keyword">from</span> <span class="string">'renderer'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">timeout</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, timeout))</span><br><span class="line"></span><br><span class="line">;<span class="function">(<span class="params"><span class="keyword">async</span> (</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> invert = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> flip = <span class="literal">false</span></span><br><span class="line">  init(invert, flip)</span><br><span class="line">  clear()</span><br><span class="line">  drawText(<span class="string">'Hello world!'</span>)</span><br><span class="line">  <span class="keyword">await</span> wait(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">  clear()</span><br><span class="line">  drawText(<span class="string">'Again!'</span>)</span><br><span class="line">  <span class="keyword">await</span> wait(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">  clear()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>其实，很多树莓派上著名的 Python 模块，也都为你做好了这一步。那为什么要用 JS 重新实现一遍呢？因为只有 JS 上才有 Learn once, write anywhere 的 React 呀！让我们走出最后一步，将 React 与这块液晶屏连接起来吧。</p>
<h2 id="实现-React-渲染后端"><a href="#实现-React-渲染后端" class="headerlink" title="实现 React 渲染后端"></a>实现 React 渲染后端</h2><p>为 React 实现渲染后端，听起来是件非常高大上的事情。其实这玩意很可能并没有你想象的那么复杂，社区也有 <a href="https://github.com/nitin42/Making-a-custom-React-renderer" target="_blank" rel="noopener">Making a custom React renderer</a> 这样不错的教程，来告诉你如何从零到一地实现自己的渲染器。不过对我来说，光有这份教程还有些不太够。关键在于两个地方：</p>
<ol>
<li>这份教程只将 React 渲染到静态的 docx 格式，不支持能持续更新的 UI 界面。</li>
<li>这份教程没有涉及接入 React Native 式的原生模块。</li>
</ol>
<p>这两个问题里，问题 2 已经在上面基本解决了：我们手里已经有了个用 JS 调一次就能画些东西的原生模块。那么剩下的问题就是，该如何实现一个支持按需更新的 React 渲染后端呢？</p>
<p>我选择的基本设计，是将整个应用分为三个宏观角色：</p>
<ul>
<li>事件驱动的 React 体系</li>
<li>维护原生屏幕状态的容器</li>
<li>固定帧率运行的渲染 Main Loop</li>
</ul>
<p>这些体系是如何协调工作的呢？简单来说，当用户事件触发了 React 中的 setState 后，React 不仅会更新自身的状态树，还会在原生状态容器中做出修改和标记。这样在 Main Loop 的下一帧到来时，我们就能根据标记，按需地刷新屏幕状态了。<strong>从事件流向的视角来看</strong>，整体架构就像这样：</p>
<p><img src="https://ewind.us/images/react-ssd1306/react-arch-1.jpg" alt></p>
<p>图中的 Native State Container 可以理解为浏览器真实 DOM 这样「不难直接写 JS 操控，但不如交给 React 帮你管理」的状态容器。只要配置正确，React 就会单向地去更新这个容器的状态。而一旦容器状态被更新，这个新状态就会在下一帧被同步到屏幕上。这其实和经典的生产者 - 消费者模型颇为类似。其中 React 是更新容器状态的生产者，而屏幕则是定时检查并消费容器状态的消费者。听起来应该不难吧？</p>
<p>实现原生状态容器和 Main Loop，其实都是很容易的。最大的问题在于，我们该如何配置好 React，让它自动更新这个状态容器呢？这就需要使用大名鼎鼎的 React Reconciler 了。要想实现一个 React 的 Renderer，其实只要在 Reconciler 的各个生命周期勾子里，正确地更新原生状态容器就行了。<strong>从层次结构的视角来看</strong>，整体架构则是这样的：</p>
<p><img src="https://ewind.us/images/react-ssd1306/react-arch-2.jpg" alt></p>
<p>可以认为，我们想在 React 中拿来使用的 JS Renderer，更像是一层较薄的壳。它下面依次还有两层重要的结构需要我们实现：</p>
<ul>
<li>一个实现了原生状态容器和原生渲染 Loop 的 Adapter 适配层</li>
<li>真正的 C 语言 Renderer</li>
</ul>
<p>React 所用的 Renderer 这层壳的实现，大致像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Reconciler <span class="keyword">from</span> <span class="string">'react-reconciler'</span></span><br><span class="line"><span class="keyword">import</span> &#123; NativeContainer &#125; <span class="keyword">from</span> <span class="string">'./native-adapter.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> NativeContainer()</span><br><span class="line"><span class="keyword">const</span> hostConfig = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">const</span> reconciler = Reconciler(hostConfig)</span><br><span class="line"><span class="keyword">const</span> container = reconciler.createContainer(root, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SSD1306Renderer = &#123;</span><br><span class="line">  render (reactElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> reconciler.updateContainer(reactElement, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中我们需要实现个 NativeContainer 容器。这个容器大概是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 QuickJS 原生模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; init, clear, drawText, drawPixel &#125; <span class="keyword">from</span> <span class="string">'renderer'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeContainer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = []</span><br><span class="line">    <span class="keyword">this</span>.synced = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 清屏，并开始事件循环</span></span><br><span class="line">    init()</span><br><span class="line">    clear()</span><br><span class="line">    mainLoop(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.onFrameTick())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交给 React 调用的方法</span></span><br><span class="line">  appendElement (element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.synced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.elements.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交给 React 调用的方法</span></span><br><span class="line">  removeElement (element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.synced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> i = <span class="keyword">this</span>.elements.indexOf(element)</span><br><span class="line">    <span class="keyword">if</span> (i !== <span class="number">-1</span>) <span class="keyword">this</span>.elements.splice(i, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每帧执行，但仅当状态更改时重新 render</span></span><br><span class="line">  onFrameTick () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.synced) <span class="keyword">this</span>.render()</span><br><span class="line">    <span class="keyword">this</span>.synced = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清屏后绘制各类元素</span></span><br><span class="line">  render () &#123;</span><br><span class="line">    clear()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.elements.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="keyword">this</span>.elements[i]</span><br><span class="line">      <span class="keyword">if</span> (element <span class="keyword">instanceof</span> NativeTextElement) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; children, row, col &#125; = element.props</span><br><span class="line">        drawText(children[<span class="number">0</span>], row, col)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> NativePixelElement) &#123;</span><br><span class="line">        drawPixel(element.props.x, element.props.y)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出这个 NativeContainer 只要内部元素被更改，就会在下一帧调用 C 渲染模块。那么该如何让 React 调用它的方法呢？这就需要上面的 <code>hostConfig</code> 配置了。这份配置中需要实现大量的  Reconciler API。对于我们最简单的初次渲染场景而言，包括这些：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">appendInitialChild () &#123;&#125;</span><br><span class="line">appendChildToContainer  () &#123;&#125; <span class="comment">// 关键</span></span><br><span class="line">appendChild () &#123;&#125;</span><br><span class="line">createInstance () &#123;&#125; <span class="comment">// 关键</span></span><br><span class="line">createTextInstance () &#123;&#125;</span><br><span class="line">finalizeInitialChildren () &#123;&#125;</span><br><span class="line">getPublicInstance () &#123;&#125;</span><br><span class="line">now () &#123;&#125;</span><br><span class="line">prepareForCommit () &#123;&#125;</span><br><span class="line">prepareUpdate () &#123;&#125;</span><br><span class="line">resetAfterCommit () &#123;&#125;</span><br><span class="line">resetTextContent () &#123;&#125;</span><br><span class="line">getRootHostContext () &#123;&#125; <span class="comment">// 关键</span></span><br><span class="line">getChildHostContext () &#123;&#125;</span><br><span class="line">shouldSetTextContent () &#123;&#125;</span><br><span class="line">useSyncScheduling: <span class="literal">true</span></span><br><span class="line">supportsMutation: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这里真正有意义的实现基本都在标记为「关键」的项里。例如，假设我的 NativeContainer 中具备 NativeText 和 NativePixel 两种元素，那么 <code>createInstance</code> 勾子里就应该根据 React 组件的 type 来创建相应的元素实例，并在 <code>appendChildToContainer</code> 勾子里将这些实例添加到 NativeContainer 中。具体实现相当简单，可以参考实际代码。</p>
<p>创建之后，我们还有更新和删除元素的可能。这至少对应于这些 Reconciler API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">commitTextUpdate () &#123;&#125;</span><br><span class="line">commitUpdate () &#123;&#125; <span class="comment">// 关键</span></span><br><span class="line">removeChildFromContainer () &#123;&#125; <span class="comment">// 关键</span></span><br></pre></td></tr></table></figure>
<p>它们的实现也是同理的。最后，我们需要跟 Renderer 打包提供一些「内置组件」，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Text = <span class="string">'TEXT'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Pixel = <span class="string">'PIXEL'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SSD1306Renderer = &#123;</span><br><span class="line">  render () &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们从 Reconciler 那里拿到的组件 type 就可以是这些常量，进而告知 NativeContainer 更新啦。</p>
<p><strong>到此为止，经过这全部的历程后，我们终于能用 React 直接控制屏幕了</strong>！这个 Renderer 实现后，基于它的代码就相当简单了：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./polyfill.js'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SSD1306Renderer, Text, Pixel &#125; <span class="keyword">from</span> <span class="string">'./renderer.js'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hello</span>: <span class="string">'Hello React!'</span>, <span class="attr">p</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; hello, p &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;Text row=&#123;<span class="number">0</span>&#125; col=&#123;<span class="number">0</span>&#125;&gt;&#123;hello&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Text row=&#123;1&#125; col=&#123;0&#125;&gt;Hello QuickJS!&lt;/</span>Text&gt;</span><br><span class="line">        &lt;Pixel x=&#123;p&#125; y=&#123;p&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentDidMount () &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ XXX: 模拟事件驱动更新</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; this.setState(&#123; hello: 'Hello Pi!', p: 42 &#125;), 2000)</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; this.setState(&#123; hello: '', p: -1 &#125;), 4000)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">SSD1306Renderer.render(&lt;App /</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>渲染结果是这样的：</p>
<p><img src="https://ewind.us/images/react-ssd1306/pi-success.jpg" alt></p>
<p>别看显示效果似乎貌不惊人，这几行文字的出现，标准着 JSX、组件生命周期勾子和潜在的 Hooks / Redux 等现代的前端技术，终于都能直通嵌入式硬件啦——将 React、QuickJS、树莓派和液晶屏连接起来的尝试，到此也算是能告一段落了。拜 QuickJS 所赐，<strong>最终包括 JS 引擎和 React 全家桶在内的整个二进制可执行文件体积，只有 780K 左右</strong>。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>上面涉及的整个项目代码示例，都在公开的 <a href="https://github.com/doodlewind/react-ssd1306" target="_blank" rel="noopener">react-ssd1306</a> 仓库中（如果你觉得有意思，来个 star 吧）。再附上些过程中较有帮助的参考链接：</p>
<ul>
<li><a href="https://bellard.org/quickjs" target="_blank" rel="noopener">QuickJS 主页</a></li>
<li><a href="https://medium.com/@calbertts/how-to-create-asynchronous-apis-for-quickjs-8aca5488bb2e" target="_blank" rel="noopener">QuickJS 异步原生模块开发</a></li>
<li><a href="https://www.raspberrypi-spy.co.uk/2018/04/i2c-oled-display-module-with-raspberry-pi/" target="_blank" rel="noopener">在树莓派上使用 I2C OLED</a></li>
<li><a href="https://github.com/nitin42/Making-a-custom-React-renderer" target="_blank" rel="noopener">构建自定义 React Renderer</a></li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果你坚持到了这里，那真是辛苦你啦~这篇文章的篇幅相当长，涉及的关键点也可能比较分散——重点到底是如何使用 QuickJS、如何编写 C 扩展，还是如何定制 React Reconciler 呢？似乎都很重要啊（笑）。不过这个过程折腾下来，确实给了我很多收获。许多以前只是听说过，或者觉得非常高大上的概念，自己动手做过之后才发现并没有那么遥不可及。其他的一些感想大概还有：</p>
<ul>
<li>有了这么方便的嵌入式 JS 引擎，Web 技术栈可以更好地走出浏览器啦</li>
<li>树莓派真的很有趣，配合 VSCode Remote 更是高效。非常推荐入手玩玩</li>
<li>I2C 的性能瓶颈真的很明显，整个系统的优化光在 React 侧做肯定还不够</li>
<li>运行 React 的「最低配置」是多少呢？一定比 Node.js 的最低配置低得多吧</li>
</ul>
<p>其实从我日常切图的时候起，我就喜欢弄些「对业务没什么直接价值」的东西，比如：</p>
<ul>
<li><a href="http://ewind.us/h5/ove-lang/demo/">支持中文关键字的类 Lisp 语言解释器</a></li>
<li><a href="https://juejin.im/post/5b837c0b51882542d950efb4" target="_blank" rel="noopener">用 WebGL 渲染魔方，并写算法还原它</a></li>
<li><a href="https://juejin.im/post/5a11729251882554b83723e5" target="_blank" rel="noopener">能玩 PONG 游戏的 Chip8 虚拟机</a></li>
</ul>
<p>这次的 react-ssd1306 项目里，驱使我的动力和造这些轮子时也是相似的。为什么不好好写业务逻辑，非要搞这些「没有意义」的事呢？</p>
<p><strong>Because we can.</strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Note/">Note</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Web/">Web</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://ewind.us/2019/react-ssd1306/" data-title="将 React 渲染到嵌入式液晶屏 | ewind the doodler" data-tsina="2804097783" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/beam/" title="如何设计一个 WebGL 基础库">
  <strong>上一篇：</strong><br/>
  <span>
  如何设计一个 WebGL 基础库</span>
</a>
</div>


<div class="next">
<a href="/2019/gui-and-ui/"  title="我不想成为不懂 GUI 的 UI 开发者">
 <strong>下一篇：</strong><br/> 
 <span>我不想成为不懂 GUI 的 UI 开发者
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景概述"><span class="toc-number">1.</span> <span class="toc-text">背景概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将-React-移植到嵌入式-JS-引擎上"><span class="toc-number">2.</span> <span class="toc-text">将 React 移植到嵌入式 JS 引擎上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于-C-语言驱动硬件"><span class="toc-number">3.</span> <span class="toc-text">基于 C 语言驱动硬件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为-JS-引擎封装-C-语言扩展"><span class="toc-number">4.</span> <span class="toc-text">为 JS 引擎封装 C 语言扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-React-渲染后端"><span class="toc-number">5.</span> <span class="toc-text">实现 React 渲染后端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源"><span class="toc-number">6.</span> <span class="toc-text">资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-number">7.</span> <span class="toc-text">后记</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="doodlewind" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript">
(function(e){var t="//cdn.jsdelivr.net/github-cards/1.0.2/";var r,i=0;var a=e.getElementsByTagName("meta");var n,d,l,c;for(r=0;r<a.length;r++){var s=a[r].getAttribute("name");var f=a[r].getAttribute("content");if(s==="gc:url"){n=f}else if(s==="gc:base"){t=f}else if(s==="gc:client-id"){d=f}else if(s==="gc:client-secret"){l=f}else if(s==="gc:theme"){c=f}}function u(t){if(e.querySelectorAll){return e.querySelectorAll("."+t)}var i=e.getElementsByTagName("div");var a=[];for(r=0;r<i.length;r++){if(~i[r].className.split(" ").indexOf(t)){a.push(i[r])}}return a}function g(e,t){return e.getAttribute("data-"+t)}function h(e){if(window.addEventListener){window.addEventListener("message",function(t){if(e.id===t.data.sender){e.height=t.data.height}},false)}}function v(r,a){a=a||n;if(!a){var s=g(r,"theme")||c||"default";a=t+"cards/"+s+".html"}var f=g(r,"user");var u=g(r,"repo");var v=g(r,"github");if(v){v=v.split("/");if(v.length&&!f){f=v[0];u=u||v[1]}}if(!f){return}i+=1;var o=g(r,"width");var m=g(r,"height");var b=g(r,"target");var w=g(r,"client-id")||d;var p=g(r,"client-secret")||l;var A="ghcard-"+f+"-"+i;var y=e.createElement("iframe");y.setAttribute("style","width:100%");y.setAttribute("id",A);y.setAttribute("frameborder",0);y.setAttribute("scrolling",0);y.setAttribute("allowtransparency",true);var E=a+"?user="+f+"&identity="+A;if(u){E+="&repo="+u}if(b){E+="&target="+b}if(w&&p){E+="&client_id="+w+"&client_secret="+p}y.src=E;y.width=o||Math.min(r.parentNode.clientWidth||400,400);if(m){y.height=m}h(y);r.parentNode.replaceChild(y,r);return y}var o=u("github-card");for(r=0;r<o.length;r++){v(o[r])}if(window.githubCard){window.githubCard.render=v}})(document);
</script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Note/" title="Note">Note<sup>135</sup></a></li>
		  
		
		  
			<li><a href="/categories/Scribble/" title="Scribble">Scribble<sup>25</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Web/" title="Web">Web<sup>66</sup></a></li>
			
		
			
				<li><a href="/tags/JS/" title="JS">JS<sup>51</sup></a></li>
			
		
			
				<li><a href="/tags/Summary/" title="Summary">Summary<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/Algorithms/" title="Algorithms">Algorithms<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/USTC/" title="USTC">USTC<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/macOS/" title="macOS">macOS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Photography/" title="Photography">Photography<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Pattern/" title="Pattern">Pattern<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Assembly/" title="Assembly">Assembly<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Visualization/" title="Visualization">Visualization<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/React/" title="React">React<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Blog/" title="Blog">Blog<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Vue/" title="Vue">Vue<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/SQL/" title="SQL">SQL<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Travel/" title="Travel">Travel<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://ustc.life" target="_blank" title=" 科大学生导航主页">ustc.life</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.unichow.com" target="_blank" title=" hengyu">Art</a>
            
          </li>
        
          <li>
            
            	<a href="https://ring0.me" target="_blank" title=" boj">Ring0</a>
            
          </li>
        
          <li>
            
            	<a href="https://sqrt-1.me" target="_blank" title=" zzh">负一的平方根</a>
            
          </li>
        
          <li>
            
            	<a href="http://0x01.me" target="_blank" title=" wzb">机智的超立方体</a>
            
          </li>
        
          <li>
            
            	<a href="https://jenny42.com" target="_blank" title=" jenny42">Jenny&#39;s Life</a>
            
          </li>
        
          <li>
            
            	<a href="http://sadhen.com" target="_blank" title=" sadhen">Sadhen</a>
            
          </li>
        
          <li>
            
            	<a href="http://chenyuelili.com/" target="_blank" title=" chenyueli">快乐小小利</a>
            
          </li>
        
          <li>
            
            	<a href="https://richardcao.me/" target="_blank" title=" richardcao">Lifecycle</a>
            
          </li>
        
          <li>
            
            	<a href="https://wangbaiyuan.cn/" target="_blank" title=" BrainWang">王柏元的博客</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> I&#39;m a Chinese web developer. <br/>
			Hope you like my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2804097783" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/doodlewind" target="_blank" class="icon-github" title="github"></a>
		
		
		
		<a href="https://twitter.com/i94ewind" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		<a href="https://www.facebook.com/doodlewind" target="_blank" class="icon-facebook" title="facebook"></a>
		
		
		<a href="https://www.linkedin.com/in/doodlewind" target="_blank" class="icon-linkedin" title="linkedin"></a>
		
		
		
		<a href="http://www.zhihu.com/people/doodlewind" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:doodlewind@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nd/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nd.svg" alt="Creative Commons" />
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a>
		Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a>
		Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
		© 2019 
		
		<a href="/about" target="_blank" title="doodlewind">doodlewind</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan hidden id='cnzz_stat_icon_1260460098'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1260460098' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
